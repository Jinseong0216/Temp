# Chapter 9: Main Memory

## 9.1 Background
- **Process**: 프로그램이 실행 중인 상태로, 주 메모리에 명령어 집합을 보유하고 있다. 프로세스는 CPU가 실행하는 작업의 기본 단위이다.
- **Memory**: 메모리는 고유 주소를 가진 바이트의 큰 배열로 구성되어 있다. CPU는 프로그램 카운터를 사용해 메모리에서 명령어를 가져오며, 이러한 명령어는 메모리에서 데이터의 로드 및 저장을 유발한다.

### Memory Space
- 각 프로세스는 별도의 메모리 공간을 가져야 한다. 이를 위해 **Base Register**와 **Limit Register**를 사용하여 유효 주소 범위를 정의한다.
- Base Register는 프로세스의 시작 주소를 가리키고, Limit Register는 프로세스가 접근할 수 있는 메모리의 최대 크기를 설정한다.

### Protection of Memory Space
- 메모리 보호는 CPU 하드웨어가 사용자 모드에서 생성된 모든 주소를 Base와 Limit Register와 비교하여 수행된다. 이는 다른 프로세스의 메모리에 접근하는 것을 방지한다.

### Address Binding
- 프로그램은 디스크에 바이너리 실행 파일 형태로 저장된다. 실행되기 위해서는 메모리로 로드되어야 한다.
- 주소는 일반적으로 기호적이며, 컴파일러는 기호 주소를 재배치 가능한 주소로 바인딩한다. 링커나 로더가 이를 절대 주소로 바인딩한다.

### Logical vs. Physical Address Space
- **Logical Address**: CPU에 의해 생성된 주소로, 프로그램이 사용하는 주소 공간을 나타낸다.
- **Physical Address**: 메모리 장치에서 볼 수 있는 주소로, 실제 메모리의 주소를 나타낸다.
- **MMU (Memory Management Unit)**: 논리 주소를 물리 주소로 매핑하는 하드웨어 장치로, 주소 변환을 담당한다.

## 9.2 Contiguous Memory Allocation
- 메모리를 가장 효율적으로 할당해야 하는 필요성이 있다. 메모리는 운영 체제와 사용자 프로세스를 위한 두 개의 파티션으로 나뉜다.
- 여러 사용자 프로세스가 동시에 메모리에 존재할 수 있다.

### Memory Protection
- 프로세스가 자신이 소유하지 않은 메모리에 접근하지 못하도록 하기 위해, relocation register와 limit register를 결합하여 메모리를 보호한다.

### Memory Allocation
- **Variable-Partition scheme**: 프로세스를 가변 크기의 파티션에 할당하는 방법이다. 각 파티션은 정확히 하나의 프로세스만 포함할 수 있다.
- **Hole**: 사용 가능한 메모리의 블록으로, 동적 메모리 할당을 위한 주요 개념이다.

### Fragmentation
- **External Fragmentation**: 메모리가 여러 개의 작은 구멍으로 조각나 있는 상태. 총 메모리 공간이 충분하더라도, 가용 공간이 연속적이지 않으면 요청을 만족하지 못할 수 있다.
- **Internal Fragmentation**: 프로세스에 할당된 메모리가 요청한 것보다 약간 더 클 때 발생한다. 이로 인해 파티션 내부에 사용되지 않는 메모리가 발생한다.

## 9.3 Paging
- Paging은 물리 주소 공간이 비연속적일 수 있도록 허용하는 메모리 관리 방식이다. 이는 연속 메모리 할당의 두 가지 문제를 해결한다: 외부 단편화 방지 및 압축 필요성 회피.
- 논리 메모리는 페이지로 나누어지고, 물리 메모리는 프레임으로 나누어진다.

### Basic Method for Paging
- CPU가 생성한 주소는 페이지 번호(p)와 페이지 오프셋(d)로 나뉜다. 이로 인해 논리 주소 공간과 물리 주소 공간은 완전히 분리된다.

### Hardware Support
- 프로세스가 실행될 때, 페이지 테이블을 재로드해야 하며, 페이지 테이블은 각 프로세스의 PCB(프로세스 제어 블록)와 함께 저장된다.
- **PTBR (Page Table Base Register)**: 페이지 테이블의 시작 주소를 가리킨다.

### TLB (Translation Look-aside Buffer)
- TLB는 빠른 조회를 위한 소형 캐시 메모리로, 페이지 테이블의 엔트리를 캐싱하여 메모리 접근 시간을 단축시킨다.

### Memory Protection with Paging
- 페이지 테이블의 각 엔트리는 보호 비트(valid-invalid bit)를 통해 메모리 보호를 수행한다. 이 비트는 페이지가 프로세스의 논리 주소 공간에 있는지 여부를 나타낸다.

### Shared Pages
- Paging의 장점 중 하나는 공통 코드를 공유할 수 있다는 것이다. 이는 특히 다중 프로그래밍 환경에서 중요한 고려 사항이다.

## 9.4 Structure of the Page Table
- 대규모 논리 주소 공간을 가지면 페이지 테이블 자체도 지나치게 커질 수 있으므로, 페이지 테이블 구조화에 대한 기술이 필요하다.

### Hierarchical Paging
- 논리 주소 공간을 여러 테이블로 나누는 방식으로, 두 개 이상의 레벨로 구성될 수 있다.

### Hashed Page Tables
- 32비트 이상의 주소 공간을 처리하기 위해 해시 테이블을 사용한다. 해시 값은 가상 페이지 번호가 된다.

### Inverted Page Tables
- 각 실제 페이지에 대한 단일 항목을 사용하여 가상 주소와 프로세스 정보를 저장하는 방식이다. 이로 인해 페이지 테이블의 크기를 줄일 수 있다.

## 9.5 Swapping
- 스와핑은 모든 프로세스의 총 물리 주소 공간이 시스템의 실제 물리 메모리를 초과할 수 있게 하여 멀티프로그래밍을 증가시킨다.
- 프로세스의 명령어와 데이터는 실행을 위해 메모리에 있어야 하며, 프로세스 또는 프로세스의 일부는 메모리에서 백업 저장소로 임시로 스와핑될 수 있다.

### Standard Swapping
- 전체 프로세스를 메인 메모리와 백업 저장소 간에 이동하는 방식이다. 그러나 전체 프로세스를 스와핑하는 비용은 매우 크다.

### Swapping with Paging
- 페이지 단위로 프로세스를 스와핑할 수 있다. 이를 통해 물리 메모리를 초과 할당할 수 있으며, 일반적으로 소수의 페이지만 스와핑된다.


# Chapter 10: Virtual Memory

## 10.1 배경
- **가상 메모리**:
  - 가상 메모리는 메모리에 완전히 존재하지 않는 프로세스를 실행할 수 있게 해주는 기술입니다. 이를 통해 운영 체제는 물리적 메모리보다 더 큰 프로그램을 실행할 수 있습니다. 프로그램이 필요한 만큼의 메모리를 동적으로 할당받고, 메모리 자원을 효율적으로 관리할 수 있습니다.
  - 가상 메모리는 메모리를 큰 저장소 배열로 추상화하여 논리 메모리와 물리 메모리를 분리합니다. 이로 인해 프로그래머는 프로그램을 작성할 때 물리적 메모리의 한계를 고려할 필요가 줄어듭니다.
  - 또한, 파일 및 라이브러리 공유를 통해 메모리 자원의 중복 사용을 줄이고, 새로운 프로세스를 생성할 때 효율적인 메커니즘을 제공합니다.

- **가상 주소 공간**:
  - 가상 주소 공간은 프로세스의 메모리 저장 방식의 논리적 표현입니다. 일반적으로 주소 0부터 시작하여 연속적으로 존재하며, 프로세스마다 독립적인 주소 공간을 제공. 이는 각 프로세스가 자신만의 메모리 공간을 가지게 되어 서로의 메모리에 영향을 주지 않도록 됨.

- **공유 메모리**:
  - 여러 프로세스가 페이지를 공유하여 파일과 메모리를 효율적으로 사용할 수 있습니다. 이를 통해 프로세스 간 데이터 전송이나 정보 공유가 용이해집니다. 공유 메모리는 주로 IPC(Inter-Process Communication) 기법으로 활용됨

- **실행 파일 로딩**:
  - 실행 파일을 로드할 때, 전체 프로그램을 메모리에 로드하는 방식과 필요할 때 페이지를 로드하는 수요 페이징 방식 존재. 후자는 메모리 사용을 최적화하고 성능을 향상시킴.

## 10.2 수요 페이징
- **기본 개념**:
  - 수요 페이징은 프로세스가 실행 중일 때 일부 페이지는 메모리에 있고, 일부는 보조 저장소에 있는 상황을 설명함. 이 때, 각 페이지의 유효성은 유효-무효 비트로 관리됨

- **페이지 폴트 처리 절차**:
  1. 프로세스가 메모리에 접근할 때 해당 주소가 유효한지 확인
  2. 유효하지만 메모리에 없는 페이지에 접근할 경우, 페이지 폴트를 발생시킴
  3. 시스템은 빈 프레임을 할당
  4. 보조 저장소에서 페이지를 읽어오는 작업을 예약
  5. 페이지가 메모리에 로드된 후 페이지 테이블을 업데이트하여 해당 페이지의 유효성을 반영
  6. 마지막으로, 페이지 폴트가 발생한 지점에서 명령어를 재시작

- **순수 수요 페이징**:
  - 순수 수요 페이징은 프로세스가 시작될 때 아무 페이지도 메모리에 로드하지 않는 방식. 필요한 페이지가 요청될 때만 메모리에 로드

- **참조 지역성**:
  - 프로그램은 종종 참조 지역성을 보여줌. 즉, 최근에 접근한 페이지가 다시 접근될 확률이 높다. 이 특성을 활용하여 페이지 폴트를 줄이고 성능을 개선할 수 있음.

- **하드웨어 지원**:
  - 페이지 테이블은 각 페이지의 유효성 여부를 표시하며, 하드웨어는 이를 통해 메모리 접근을 효율적으로 관리. 보조 저장소는 페이지가 필요할 때 임시 저장소로 작용하여 성능 저하를 방지합.

- **명령어 재시작**:
  - 페이지 폴트가 발생한 후 프로세스는 중단된 지점에서 재개할 수 있도록 설계되어 있음. 이는 효율적인 프로그램 실행을 가능하게 함.

- **성능 지표**:
  - 성능을 측정하기 위해 메모리 접근 시간 및 페이지 폴트 확률을 고려하여 효과적인 접근 시간(EAT)을 계산. EAT는 평균 메모리 접근 시간을 나타내며, 시스템 성능의 중요한 척도로 사용.

## 10.3 복사-쓰기
- **복사-쓰기(Copy-On-Write)**:
  - 프로세스가 공유하는 페이지를 수정할 때, 복사-쓰기 전략을 사용하여 필요한 경우에만 페이지를 복사합니다. 이 기법은 `fork()`와 `exec()`를 통한 프로세스 생성 시 매우 유용합니다. 초기에는 두 프로세스가 동일한 페이지를 참조하다가, 한 프로세스가 페이지를 수정하면 해당 페이지가 복사되어 독립적인 메모리 공간이 생성됩니다. 이를 통해 메모리 사용을 최소화하고 성능을 높일 수 있습니다.

## 10.4 페이지 교체
- **페이지 교체 필요성**:
  - 사용 가능한 프레임이 부족할 때 페이지 교체가 필요합니다. 이 경우, 운영 체제는 메모리에 있는 페이지 중 하나를 선택하여 보조 저장소로 이동시키고, 새로운 페이지를 메모리에 로드합니다.

- **페이지 교체 절차**:
  1. 보조 저장소에서 원하는 페이지의 위치를 찾습니다.
  2. 교체할 프레임을 선택합니다. 이 선택은 페이지 교체 알고리즘에 따라 다릅니다.
  3. 페이지 테이블과 프레임 테이블을 업데이트합니다.
  4. 페이지 폴트가 발생한 지점에서 프로세스의 실행을 재개합니다.

- **프레임 할당 전략**:
  - 각 프로세스에 몇 개의 프레임을 할당할 것인가에 대한 결정이 필요합니다. 이는 전체 메모리 자원을 효율적으로 사용하는 데 영향을 미칩니다.
  - **전역 할당**: 모든 프로세스가 사용할 수 있는 프레임을 공유합니다.
  - **지역 할당**: 각 프로세스에 고정된 수의 프레임을 할당하여 독립적으로 사용합니다.

- **페이지 교체 알고리즘**:
  - **FIFO (First-In, First-Out)**: 가장 오래된 페이지를 교체합니다. 단순하지만 효율성이 떨어질 수 있습니다.
  - **OPT (Optimal)**: 가장 오랫동안 사용되지 않을 페이지를 교체합니다. 이론적으로 가장 효율적이지만, 구현이 어렵습니다.
  - **LRU (Least Recently Used)**: 가장 최근에 사용되지 않은 페이지를 교체합니다. 페이지 참조 기록을 유지해야 하므로 구현이 복잡할 수 있습니다.
  - **두 번째 기회 (Second Chance)**: FIFO의 변형으로, 참조 비트를 사용하여 페이지가 사용된 적이 있는지 확인하고 교체 여부를 결정합니다.

## 10.5 프레임 할당
- **프레임 할당 전략**:
  - **동일 분배**: 각 프로세스에 동일한 수의 프레임을 할당합니다.
  - **비례 분배**: 프로세스의 크기나 요구에 따라 프레임을 비례적으로 할당합니다. 이는 메모리 자원을 더 효율적으로 사용할 수 있게 합니다.
  - **전역 vs. 지역**: 전역 할당은 모든 프로세스가 사용할 수 있는 프레임을 고려하고, 지역 할당은 각 프로세스의 요구에 맞춰 독립적으로 할당합니다.

## 10.6 스래싱
- **스래싱(Thrashing)**:
  - 스래싱은 페이지 교체가 너무 잦아 시스템 성능이 저하되는 상태를 의미합니다. 시스템은 유용한 작업을 수행하기보다 페이지 교체에 많은 시간을 소모하게 됩니다.
  - 스래싱을 방지하기 위해, 시스템은 각 프로세스가 필요한 페이지 집합을 적절히 관리해야 하며, 적절한 메모리 양을 확보해야 합니다.
  
- **작업 집합 모델**:
  - 작업 집합 모델은 최근에 접근한 페이지의 집합을 정의하여 지역성을 기반으로 합니다. 이 모델은 프로세스가 메모리에서 활동적으로 사용되는 페이지 집합을 규명하여 스래싱을 방지하는 데 기여합니다.
  - 운영 체제는 프로세스의 작업 집합을 이해하고 이를 기반으로 필요한 메모리 할당량을 조정할 수 있습니다.



# Chapter 11: 대용량 저장 구조

## 11.1 대용량 저장 구조 개요
- **대용량 저장**: 컴퓨터 시스템에서 비휘발성 데이터를 저장하는 시스템으로, 전원이 꺼져도 데이터가 유지됩니다. 주로 사용되는 저장 장치는 다음과 같습니다:
  - **HDD(하드 디스크 드라이브)**: 기계적인 움직임을 통해 데이터를 저장하고 검색하는 장치.
  - **NVM(비휘발성 메모리)**: 플래시 메모리와 같은 전자적 방식으로 데이터를 저장하는 장치로, 더 빠른 접근 속도를 제공합니다.
  - **기타**: 자기 테이프, 광디스크, 클라우드 저장소 등 다양한 형태의 저장매체가 존재하며, 특히 RAID(중복 독립 디스크 배열) 시스템을 사용하여 데이터의 안전성과 접근 속도를 개선할 수 있습니다.

## 11.2 HDD 스케줄링
- **스케줄링의 목표**: HDD의 성능을 극대화하기 위해 데이터 접근 시간을 최소화하고 데이터 전송 대역폭을 최대화합니다.
  
### 탐색 시간 및 회전 대기 시간
- **탐색 시간**: 장치 팔이 원하는 섹터가 포함된 실린더로 이동하는 데 걸리는 시간입니다. 이는 HDD의 성능에 큰 영향을 미칩니다.
- **회전 대기 시간**: 플래터가 원하는 섹터를 헤드에 맞추는 데 추가로 소요되는 시간으로, 두 가지 요소를 모두 고려하여 스케줄링 알고리즘을 설계해야 합니다.

### 디스크 대역폭
- **정의**: 전송된 총 바이트 수를 첫 요청과 마지막 전송 완료 사이의 총 시간으로 나눈 값입니다. 이는 데이터 전송의 효율성을 나타내는 중요한 지표입니다.

### 스케줄링 알고리즘
1. **FIFO(First-In-First-Out)**:
   - **설명**: 요청이 들어온 순서대로 처리하는 방식으로, 공정성이 보장되지만 속도는 일반적으로 느립니다.
   - **총 헤드 이동량**: 640 실린더.
  
2. **SCAN(스캔)**:
   - **작동 방식**: 디스크의 한 쪽 끝에서 시작하여 반대 쪽으로 이동하며 요청을 처리하고, 반대 끝에 도달하면 방향을 바꾸어 다시 요청을 처리합니다.
   - **총 헤드 이동량**: 236 실린더.

3. **C-SCAN(순환 스캔)**:
   - **특징**: 요청 처리 후 한 쪽 끝에 도달하면 즉시 시작점으로 돌아가면서 요청을 처리하지 않음. 이는 대기 시간을 더 균일하게 만들어줍니다.
   - **총 헤드 이동량**: 183 실린더(199에서 0까지 무시).

## 11.3 NVM 스케줄링
- **비휘발성 메모리**의 스케줄링은 데이터 접근의 속도를 최적화하는 다양한 기술을 포함합니다. 이러한 기술들은 메모리의 구조적 특성에 따라 달라지며, 대기 시간을 최소화하고 데이터 전송 속도를 극대화하는 데 중점을 둡니다.

## 11.4 오류 탐지 및 수정
- **오류 탐지**: 데이터 전송 중 발생할 수 있는 오류를 탐지하기 위한 다양한 기법들이 있습니다. 예를 들어, 체크섬이나 해시 함수를 사용하여 데이터의 무결성을 검증할 수 있습니다.
- **오류 수정**: 오류가 발생했을 경우 이를 자동으로 수정할 수 있는 방법으로, 주로 ECC(오류 정정 코드)가 사용됩니다. 이는 저장된 데이터의 신뢰성을 높이는 중요한 요소입니다.

## 11.5 저장 장치 관리
- **목표**: 다양한 저장 장치의 효율적인 관리와 최적화를 통해 시스템 성능을 극대화하는 것입니다. 이는 저장 장치의 상태를 모니터링하고 필요한 경우 유지 관리 절차를 실행하는 것을 포함합니다.

## 11.6 스왑 공간 관리
- **스왑 공간**: 주 메모리가 부족할 때 사용하는 보조 저장 공간으로, 프로세스의 데이터를 디스크에 저장하여 메모리를 확보합니다.
- **관리 방식**: 스왑 공간의 효율적인 할당과 회수 방법을 통해 시스템의 전반적인 성능을 유지합니다.

## 11.7 저장 장치 부착
- **저장 장치 연결 방법**: 내부 저장 장치와 외부 저장 장치의 연결 방식을 관리하여, 시스템의 확장성과 유연성을 높이는 것이 중요합니다. 다양한 인터페이스(예: SATA, USB 등)를 통해 저장 장치가 연결될 수 있습니다.

## 11.8 RAID 구조
- **RAID (Redundant Arrays of Independent Disks)**:
  - 데이터 읽기 및 쓰기 속도를 향상시키기 위한 다양한 디스크 조직 기술을 포함합니다. RAID는 여러 개의 드라이브를 병렬로 운영하여 성능을 개선하고, 중복 데이터를 통해 신뢰성을 높입니다.
  
### 중복성
- **신뢰성 향상**: RAID 시스템에서 여러 디스크에 중복 데이터를 저장함으로써 하나의 드라이브가 실패하더라도 데이터 손실을 방지할 수 있습니다.
- **MTBF(Mean Time Between Failures)**: 평균 고장 간격을 측정하며, 디스크 배열 내 고장 확률을 줄이는 데 기여합니다.

### 병렬성
- **성능 개선**: 여러 드라이브를 통해 데이터 전송 속도를 향상시키며, 스트라이핑(data striping)을 통해 데이터를 여러 드라이브에 분산 저장합니다.


# Chapter 12: I/O 시스템

## 12.1 개요
- **I/O 시스템의 중요성**: 컴퓨터의 주요 작업은 I/O(입출력)와 계산이며, 많은 경우 I/O 작업이 더 많은 시간을 차지합니다. 예를 들어 웹 브라우징, 파일 편집, 게임 등 다양한 작업에서 I/O가 주된 역할을 합니다.
- **운영 체제의 역할**: I/O 작업 및 I/O 장치를 관리하고 제어하는 것입니다. 이를 통해 사용자와 하드웨어 간의 원활한 상호작용을 보장합니다.

## 12.2 I/O 하드웨어
- **구성 요소**: I/O 시스템은 CPU, 메모리, I/O 장치로 구성됩니다. 각 장치는 데이터를 전송하고 명령을 수행하는 고유한 방식으로 작동합니다.
- **버스 아키텍처**: 다양한 I/O 장치가 CPU와 메모리와 어떻게 연결되는지를 설명하는 일반적인 구조입니다.

## 12.3 응용 프로그램 I/O 인터페이스
- **정의**: 응용 프로그램이 I/O 작업을 수행하기 위해 운영 체제와 상호작용하는 방법을 정의합니다. 이는 시스템 호출을 통해 이루어지며, 프로그래머가 I/O 장치를 제어할 수 있도록 도와줍니다.
- **시스템 호출 예**: 파일 읽기, 쓰기, 장치 제어 등.

## 12.4 커널 I/O 서브시스템
- **기능**: I/O 장치와 프로세스 간의 데이터 전송을 관리하며, 다양한 I/O 요청을 처리합니다. 커널은 이 모든 작업을 안전하고 효율적으로 수행하도록 설계되어 있습니다.

## 12.5 I/O 요청을 하드웨어 작업으로 변환
- **작업 흐름**: 응용 프로그램에서 발생한 I/O 요청이 커널에 전달되고, 커널은 이를 적절한 하드웨어 작업으로 변환합니다.
- **큐 관리**: 여러 I/O 요청을 효율적으로 처리하기 위해 큐를 관리하고, 요청을 적절히 스케줄링합니다.

## 12.6 스트림
- **정의**: 데이터가 연속적으로 흐르는 형태로, I/O 시스템에서 데이터를 처리하는 기본적인 방법입니다. 스트림은 프로그램이 데이터를 순차적으로 읽고 쓸 수 있도록 합니다.
- **유형**: 스트림에는 입력 스트림과 출력 스트림이 있으며, 이를 통해 데이터의 흐름을 관리합니다.

## 12.7 성능
- **성능 지표**: I/O 시스템의 성능은 처리 속도, 대기 시간, 처리량 등으로 평가됩니다. 이러한 지표들은 시스템의 효율성을 나타내며, 이를 개선하기 위한 다양한 기법들이 존재합니다.
- **최적화 방법**: 캐싱, 버퍼링, 병렬 처리 등을 통해 I/O 성능을 극대화할 수 있음.



